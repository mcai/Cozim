`include "config.sv"

// Synchronous FIFO for the specific packet type generated by the NetEmulation framework, created using a
// memory array.  Each location in memory has an associated pointer store for both the read and write and
// write pointer.  The pointers are each a single bit which rotate around the different pointer stores
// according to read and write requests.
module fifo_packet
#(
  parameter DEPTH = 4
)
 (
  input logic clk,
  input logic ce,
  input logic reset_n,

  input packet_t i_data, // input data of the packet_t type to be stored into the FIFO
  input logic i_data_val, // Validates the data on i_data.  If high, i_data will be sampled.
  input logic i_en, // Inputs an enable, if high on a clock edge, o_data was read from memory

  output packet_t o_data, // Output data of the packet_t type to be sent from the FIFO
  output logic o_data_val, // Validates the data on o_data, held high until input enable received
  output logic o_en // Outputs an enable, if high, i_data is written to memory
);

  typedef struct{logic rd_ptr, wr_ptr;} ptr;
  
  ptr l_mem_ptr [DEPTH-1:0];
  packet_t l_mem [DEPTH-1:0];

  logic l_full, l_empty, l_near_empty;

  always_ff@(posedge clk) begin
    if(~reset_n) begin
      for(int i=0; i<DEPTH; i++) begin
        l_mem[i] <= 0;
      end
      l_mem_ptr[0].rd_ptr <= 1;
      l_mem_ptr[0].wr_ptr <= 1;
      for(int i=1; i<DEPTH; i++) begin
        l_mem_ptr[i].rd_ptr <= 0;
        l_mem_ptr[i].wr_ptr <= 0;
      end
      o_data <= 0;

      l_full <= 0;
      l_empty <= 1;
    end else begin
      if(ce) begin
        // Memory Write
        // ------------------------------------------------------------------------------------------------------------
        if(i_data_val && ~l_full) begin
          // Write Data to memory location indicated by the write pointer
          for(int i=0; i<DEPTH; i++) begin
            l_mem[i] <= l_mem_ptr[i].wr_ptr ? i_data : l_mem[i];
          end
          // Increment the write pointer to the next memory location
          for(int i=0; i<DEPTH-1; i++) begin
            l_mem_ptr[i+1].wr_ptr <= l_mem_ptr[i].wr_ptr;
          end
          l_mem_ptr[0].wr_ptr <= l_mem_ptr[DEPTH-1].wr_ptr;
        end

        // Output Write
        // ------------------------------------------------------------------------------------------------------------
        if(i_en && ~l_empty) begin
          // Data was read from memory so the next data needs loading into the output.
          if(l_near_empty) begin
            // Next memory location is currently empty,
            if(i_data_val) begin
              // New data is being loaded
              o_data <= i_data;
            end else begin
              // FIFO has emptied
              o_data <= o_data;
            end
          end else begin
            // Next memory location already contains next data
            for(int i=0; i<DEPTH; i++) begin
              if (l_mem_ptr[i].rd_ptr) begin
                if(i<DEPTH-1) begin
                  o_data <= l_mem[i+1];
                end else begin
                  o_data <= l_mem[0];
                end
              end
            end
          end
          // Increment Read Pointer.
          for(int i=0; i<DEPTH-1; i++) begin
            l_mem_ptr[i+1].rd_ptr <= l_mem_ptr[i].rd_ptr;
          end
          l_mem_ptr[0].rd_ptr <= l_mem_ptr[DEPTH-1].rd_ptr;
        end else if(l_empty && i_data_val) begin
          // Data was written into empty memory, output should be updated immediately
          o_data <= i_data;
        end else begin
          // Data was not read from memory, the output currently holds a valid packet, keep output data the same.
          for(int i=0; i<DEPTH; i++) begin
            if(l_mem_ptr[i].rd_ptr) o_data <= l_mem[i];
          end
        end

        // Full Flag.
        // ------------------------------------------------------------------------------------------------------------
        if (~l_full) begin
          if(i_data_val && ~i_en) begin
            for(int i=0; i<DEPTH; i++) begin
              if(l_mem_ptr[i].wr_ptr) begin
                l_full <= (i<DEPTH-1) ? l_mem_ptr[i+1].rd_ptr : l_mem_ptr[0].rd_ptr;
              end
            end
          end
        end else if (l_full) begin
          l_full <= (i_en) ? 1'b0 : 1'b1;
        end

        // Empty Flag and Output Valid.
        // ------------------------------------------------------------------------------------------------------------
        if (~l_empty) begin
          if(~i_data_val && i_en) begin
            for(int i=0; i<DEPTH; i++) begin
              if(l_mem_ptr[i].rd_ptr) begin
                l_empty <= (i<DEPTH-1) ? l_mem_ptr[i+1].wr_ptr : l_mem_ptr[0].wr_ptr;
              end
            end
          end
        end else if (l_empty) begin
          l_empty <= (i_data_val) ? 1'b0 : 1'b1;
        end
		  
        // Nearly Empty Flag.
        // ------------------------------------------------------------------------------------------------------------
        if (~l_near_empty) begin
          if(l_empty) begin
            l_near_empty <= i_data_val ? 1'b1 : 1'b0;
          end else if(~l_empty) begin
            if(~i_data_val && i_en) begin
              for(int i=0; i<DEPTH; i++) begin
                if(l_mem_ptr[i].rd_ptr) begin
                  if(i<DEPTH-2) begin
                    l_near_empty <= l_mem_ptr[i+2].wr_ptr;
                  end else if(i==DEPTH-2) begin
                    l_near_empty <= l_mem_ptr[0].wr_ptr;
                  end else begin
                    l_near_empty <= l_mem_ptr[1].wr_ptr;
                  end
                end
              end
            end
          end
        end else if(l_near_empty) begin
          l_near_empty <= (i_en ^~ i_data_val) ? 1'b1 : 1'b0;
        end

      end
    end
  end

  // Valid/Enable.  Note, valid is simply the inverse of empty.  Also, enable is simply the inverse of full.
  assign o_data_val = ~l_empty;
  assign o_en = ~l_full;

endmodule
